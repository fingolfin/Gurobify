<?xml version="1.0" encoding="UTF-8"?>

<!-- This is an automatically generated file. -->
<Chapter Label="Chapter_Examples">
<Heading>Examples</Heading>

This section contains a number of examples which are intended to illustrate the usage of Gurobify.
<Section Label="Chapter_Examples_Section_Sudoku_solver">
<Heading>Sudoku solver</Heading>

The purpose of the example
Statement of the problem
The method applied
Defining the variables with a view to the constraints (all diff)
In this instance we name the variables since that is of use to us
<Example><![CDATA[
gap> var_names :=[];
[  ]
gap> for i in [1 .. 9] do
>      for j in [1 .. 9] do
>        for k in [1 .. 9] do
>          name := Concatenation("x", String(i), String(j), String(k));;
gap>          Add(var_names, name);
gap>        od;
gap>      od;
gap>    od;
]]></Example>


Create the model. We need to tell Gurobi that each variable is binary.
<Example><![CDATA[
gap> var_types := ListWithIdenticalEntries( Size( var_names ), "Binary" );;
gap> model := GurobiNewModel( var_types, var_names );
<object>
]]></Example>


Here we define a few basic functions which are purely for the purpose of this example.
Firstly a way to go from a subset of the variables to the corresponding index set.
Secondly, a way of going back from the index set to identify the variable name.
Lastly, a method of displaying the Sudoku board given the variables which are in the solution set.
<Example><![CDATA[
gap> ExampleFuncNamesToIndex := function( vari_names, var_included )
>      local vars, ind;
gap>      vars := ListWithIdenticalEntries( Size( var_names ), 0 );
gap>      ind := List( var_included, t -> Position( var_names, t ));
gap>      vars{ ind }:=ListWithIdenticalEntries( Size( var_included ), 1 );
gap>      return vars;
gap> end;
gap> ExampleFuncIndexToNames := function( var_names, index_set )
>   return Filtered( var_names, t -> index_set[Position( var_names, t )] = 1. );
gap> end;
gap> ExampleFuncDisplaySudoku := function( sol2 )
>      local mat_sol, m, i, j, k;
gap>        mat_sol := NullMat(9, 0);;
gap>        for m in sol2 do
>          i := EvalString( [m[2]] );
gap>          j := EvalString( [m[3]] );
gap>          k := EvalString( [m[4]] );
gap>          mat_sol[i][j] := k;
gap>        od;
gap>      Display(mat_sol);
gap> end;
]]></Example>


Ensure that a square only takes a single value.
<Example><![CDATA[
gap> for i in [1 .. 9] do
>      for j in [1 .. 9] do
>        uniqueness_constr :=[];
gap>          for k in [1 .. 9] do
>            name := Concatenation("x", String(i), String(j), String(k));;
gap>            Add(uniqueness_constr, name);
gap>          od;
gap>          constr := ExampleFuncNamesToIndex( var_names, uniqueness_constr );
gap>          GurobiAddConstraint( model, constr , "=", 1 );
gap>      od;
gap> od;
]]></Example>


Ensure that each value occurs exactly once per row.
<Example><![CDATA[
gap> for i in [1 .. 9] do
>      for k in [1 .. 9] do
>        row_constr :=[];
gap>        for j in [1 .. 9] do
>          name := Concatenation("x", String(i), String(j), String(k));;
gap>          Add(row_constr, name );
gap>        od;
gap>        constr := ExampleFuncNamesToIndex( var_names, row_constr );
gap>        GurobiAddConstraint( model, constr, "=", 1 );
gap>      od;
gap> od;
]]></Example>


Ensure that each value occurs exactly once per column.
<Example><![CDATA[
gap> for j in [1 .. 9] do
>      for k in [1 .. 9] do
>        column_constr :=[];
gap>        for i in [1 .. 9] do
>          name := Concatenation("x", String(i), String(j), String(k));;
gap>          Add(column_constr, name);
gap>        od;
gap>        constr := ExampleFuncNamesToIndex( var_names, column_constr );
gap>        GurobiAddConstraint(model, constr, "=", 1);
gap>      od;
gap> od;
]]></Example>


Ensure that each value occurs exactly once per sub-square. We start at the top left corner of each square and work our way through them.
<Example><![CDATA[
gap> starter_points := [ [1,1], [1,4], [1,7], [4,1], [4,4],
> [4,7], [7,1], [7,4], [7,7]];
[ [ 1, 1 ], [ 1, 4 ], [ 1, 7 ], [ 4, 1 ], [ 4, 4 ], [ 4, 7 ], [ 7, 1 ], [ 7, 4 ], [ 7, 7 ] ]
gap> for m in starter_points do
>      for k in [1 .. 9] do
>        square_constr := [];
gap>        for i in [0 .. 2] do
>          for j in [0 .. 2] do
>            name := Concatenation( 
>            	  "x", String(m[1] + i), String(m[2] + j), String(k)
>            	);;
gap>            Add(square_constr, name);
gap>          od;
gap>        od;
gap>        constr := ExampleFuncNamesToIndex( var_names, square_constr );
gap>        GurobiAddConstraint(model, constr, "=", 1);
gap>      od;
gap> od;
]]></Example>


Now that the lp file will look for solutions that obey the Sudoku rules,
we can put in the inital Sudoku configuration by assigning certain entries of the
sudoku matrix set values.
<Example><![CDATA[
gap> starter_squares := ["x112", "x123", "x164", "x217", "x248", "x326",
> "x343", "x391", "x411", "x422", "x488", "x516", "x549", "x568", 
> "x595", "x625", "x682", "x693", "x719", "x767", "x785", "x865", 
> "x894", "x942", "x986", "x998"];
gap> constr := ExampleFuncNamesToIndex(var_names, starter_squares);;
gap> GurobiAddConstraint( model, constr , "=", Sum( constr ), "StarterSquares");
]]></Example>


Now we optimize. Change the solution into the variable names, and then display.
<Example><![CDATA[
gap> GurobiOptimizeModel( model );
gap> sol := GurobiSolution( model );;
gap> sol2 := ExampleFuncIndexToNames( var_names, sol );;
gap> ExampleFuncDisplaySudoku( sol2 );
[ [  2,  3,  1,  6,  5,  4,  8,  9,  7 ],
  [  7,  9,  4,  8,  1,  2,  5,  3,  6 ],
  [  5,  6,  8,  3,  7,  9,  2,  4,  1 ],
  [  1,  2,  7,  5,  3,  6,  4,  8,  9 ],
  [  6,  4,  3,  9,  2,  8,  7,  1,  5 ],
  [  8,  5,  9,  7,  4,  1,  6,  2,  3 ],
  [  9,  1,  6,  4,  8,  7,  3,  5,  2 ],
  [  3,  8,  2,  1,  6,  5,  9,  7,  4 ],
  [  4,  7,  5,  2,  9,  3,  1,  6,  8 ] ]
]]></Example>


At this point we may wish to save the model as an lp file so that other Sudoku problems
may be quickly and easily solved in the future.
Of course, we do not want to save the starter configuration, only the general Sudoku constraints,
and so we must first delete the the constraint "StarterSquares".
<Example><![CDATA[
gap> GurobiDeleteConstraintsWithName( model, "StarterSquares" );
gap> GurobiWriteToFile( model, "SudokuSolver.lp" );
]]></Example>


We can now load the lp file to create a new model with all the generic Sudoku constraints.
Assuming we have defined the functions ExampleFuncNamesToIndex, ExampleFuncIndexToNames
and ExampleFuncDisplaySudoku as before,
we may simply add a new constraint to the model to represent the starting configuration of the
Sudoku problem. Assuming we do not remember the variable names or their order,
we must first extract this information from the model. We then optimize the model and display
the solution as before. Incase we have forgotten the names of the variables, or the order they occur,
or simply don't want to reconstruct the var_names list, we can first extract this information directly from the model.
<Example><![CDATA[
gap> model2 := GurobiReadModel( "SudokuSolver.lp" );
gap> var_names2 := GurobiVariableNames(model2);
gap> starter_squares := ["x118", "x124", "x132", "x145", "x161", "x219",
>  "x337", "x353", "x414", "x425", "x441", "x539", "x544", "x562", 
>  "x573", "x669", "x686", "x691", "x754", "x778", "x894", "x947", 
>  "x968", "x971", "x985", "x999"];
gap> constr := ExampleFuncNamesToIndex(var_names2, starter_squares);;
gap> GurobiAddConstraint(model2, constr , "=", Sum( constr ));
gap> GurobiOptimizeModel(model2);
gap> sol := GurobiSolution(model2);;
gap> sol2 := ExampleFuncIndexToNames(var_names2, sol);;
gap> ExampleFuncDisplaySudoku( sol2 );
[ [  8,  4,  2,  5,  9,  1,  7,  3,  6 ],
  [  9,  3,  1,  6,  2,  7,  5,  4,  8 ],
  [  5,  6,  7,  8,  3,  4,  9,  1,  2 ],
  [  4,  5,  3,  1,  8,  6,  2,  9,  7 ],
  [  6,  1,  9,  4,  7,  2,  3,  8,  5 ],
  [  2,  7,  8,  3,  5,  9,  4,  6,  1 ],
  [  1,  9,  6,  2,  4,  5,  8,  7,  3 ],
  [  7,  8,  5,  9,  1,  3,  6,  2,  4 ],
  [  3,  2,  4,  7,  6,  8,  1,  5,  9 ] ]
]]></Example>


What if we removed a initial value from the Sudoku problem? How many solutions would there be?
We remove set an entry from the starter configuration and then optimize.
We feed this solution back in as a constraint, and then reoptimize. We can repeat this process
until we have found all feasible solutions, which will be when the model becomes infeasible.
<Example><![CDATA[
gap> model3 := GurobiReadModel( "SudokuSolver.lp" );
gap> var_names3 := GurobiVariableNames(model3);
gap> starter_squares := ["x118", "x124", "x132", "x145", "x161", "x219",
>  "x337", "x353", "x414", "x425", "x441", "x539", "x544", "x562", 
>  "x573", "x669", "x686", "x691", "x754", "x778", "x894", "x947", 
>  "x968", "x971", "x985"];
gap> constr := ExampleFuncNamesToIndex(var_names3, starter_squares);;
gap> GurobiAddConstraint( model3, constr , "=", Sum( constr ));
gap> GurobiOptimizeModel( model3 );
gap> if GurobiStatus( model3 ) = 2 then
> 	number_of_solutions := 1;
gap> else
> 	number_of_solutions := 0;
gap> fi;
gap> while GurobiStatus( model3 ) = 2 do
> 	sol := GurobiSolution( model3 );;
gap> 	number_of_solutions := number_of_solutions + 1;
gap> 	GurobiAddConstraint( model3, sol , "<", 80 );
gap> 	GurobiOptimizeModel( model3 );
gap> od;
gap> Print( number_of_solutions, "\n");
67
]]></Example>


</Section>


</Chapter>

